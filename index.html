<link rel="stylesheet" type="text/css" href="css/styles.css">
<!DOCTYPE html>
<html>
    
<head>
	<h1 style="margin:0 9%; font-size:200%; padding:30px 6%; background-color: white; border: 0.8px solid #D3D3D3"><b>Quantum Minds</b></h1>
</head>

	<div style="margin: 0 9%; font-size:13px; padding: 0.1px 6%; background-color: #F5F5F5">
    	<p> 6653057 - Published: October 12, 2023 - Last Updated: December 5, 2023</p>
    </div>
    
<body background="image/TechBackground.jpg">
    <div class="NavBar">
		<a style="background-color: #21213E;" href="index.html">Article</a>
	    <a style="background-color: #28294D;" href="html/Technology">Technology</a>
	    <a style="background-color: #36376E;" href="html/Health.html">Health</a>
	    <a style="background-color: #414286;" href="html/Environment.html">Environment</a>
	    <a style="background-color: #4D4E9F;" href="html/Space.html">Space</a>
	    <a style="background-color: #5C5DBB;" href="html/Mathematics.html">Mathematics</a>
		<a style="background-color: #6769D5;" href="html/Physics.html">Physics</a>
    </div>

<div style="margin-top: 20px;">

	<div class="nav">
    	<ul style="list-style-type: none; padding-left: 0; margin: 0%;">
          <li><a href="#Abstract">Abstract</a></li>
          <li><a href="#Introduction">Introduction</a></li>
          <li><a href="#Analysis/Discussion">Analysis and Discussion</a></li>
          <li><a href="#Conclusion">Conclusion</a></li>
		  <li><a href="#References">References</a></li>
       	</ul>
    </div>

	<article>
		<h2 style="font-size: 30px;">Evolution of Message Queues: The architecture of Distributed Messaging</h2>
		<br>
	    <h2 id="Abstract">Abstract</h2>
	    <p>
        	I checked in for the night at Out O The Way motel. What a bad choice that was. First I took a shower and a spider crawled out of the drain. Next, the towel rack fell down when I reached for the one small bath towel. This allowed the towel to fall halfway into the toilet. I tried to watch a movie, but the remote control was sticky and wouldn’t stop scrolling through the channels. I gave up for the night and crawled into bed. I stretched out my leg and felt something furry by my foot. Filled with fear, I reached down and to my surprise, I pulled out a raccoon skin pair of underwear. After my initial relief that it wasn’t alive, the image of a fat, ugly businessman wearing raccoon skin briefs filled my brain. I jumped out of the bed, threw my toothbrush into my bag, and sprinted towards my car.
        </p>
		
		<h2 id="Introduction">Introduction</h2>
	    <p>
        	What are message queues? It’s as simple as it sounds, queues in which messages are stored. If you look at your phones you will see emails all piled up for you to look at your leisure. That’s what message queue is. Another example and a good way to look at it is when you go to a café. Let’s say a customer wants some coffee, He goes up to the cashier and orders. For this to work effectively, The cashier cannot go to the back and start making coffee and wait for coffee to be made. especially when there are queues behind the customer. Who will take the orders? It’s not efficient at all. For a message queue to work, we need asynchronous processing, allowing the cashier to take the next order without delay. Persistence to ensure the customer’s orders are not missed if a problem occurs.
			
			<img src="image/MessageQueueDiagram.jpg" alt="Message Queue Diagram" width="750" height="500" style="margin: 50 0;">
			
			Here's a simple diagram of message queue architecture. The cashier registers orders into a queue. The cashier is then free to take as many orders as he wants without any delays, while the coffee maker picks up new orders in batches. Once an order is complete, the coffee maker marks the order as done in the database. After, the customer can come collect the coffee at the counter at their leisure. There is no wasted time between the actions of workers whom we can refer to as ‘broker’.
			For large companies that need messaging systems, few key factors are considered: Scalability, Flexibility, Reliability, and efficiency.
		</p>
		<h2 id="Analysis/Discussion">Analysis & Discussion</h2>
	    <p>
			<h3>Point-to-Point and Publish-and-Subscribe Messaging Model</h3>
        	There are two styles in which a message can be queued. Point-to-point messaging and Publish-and-subscribe messaging. In a point-to-point model, messages are exchanged through queues, where messages are all individually unique to one consumer. After the consumer has received the message, it will then be discarded from the queue.[5]
In a publish-and-subscribe messaging, the sender doesn’t need to know the receiver while in point-to-point they do. This is because the message model sends to multiple consumers through a certain topic, which links the sender and consumer. It is the choice of the consumers to subscribe to the topic or not.[5]
“One important difference between point-to-point and publish/subscribe messaging is that p2p messages are always delivered, regardless of the current connection status of the receiver. Once a message is delivered to a queue, it stays there even if no consumer is currently connected.”[1]
		</p>
			<h3>The Evolution of Message Queuing Systems</h3>
        <p>
			One of the first few systems made was the IBMMQ. It was built for high scalability and reliability, able process high volumes of applications for commercial use. [3]
Then came the RabbitMQ, an open-sourced system. Unlike the IBMMQ, it supports a variety of protocols such as sorting messages by topic and priority. It is lightweight and simple to use. RabbitMQ works like a messaging middleware. It pushes messages to consumers and deletes them upon acknowledgement, avoiding message pileups. It is able to handle tens of thousands of messages per second.[2][3]

			<img src="image/EvolutionDiagram.gif" alt="Evolution Diagram" width="500" height="800" style="margin: 50 0; position: centered;">
			
			Unlike RabbitMQ, Kafka doesn’t support priority queues. It partitions topics into multiple brokers, allowing it to massively scale. Kafka was originally built for massive log processing. It retains messages until expiration and lets consumers pull messages at their own pace. This allows Kafka to  handle millions of data processing every second. Many modern applications integrate Kafka by default, making it a natural fit for most cases. [2]
Lastly Pulsar, one of the latest message queuing systems, Uses alternative storage methods like bookkeeper and bookies to achieve high scalability and performance.

        </p>
		
		<h2 id="Conclusion">Conclusion</h2>
	    <p>
        	Enterprises have produced more and more data ever since the birth of the Internet. In 2010, the arrival of the mobile Internet made the Internet, a super entrance, fully accessible and popular. In that year, there were 1.97 billion Internet users in the world, accounting for 28.7% of the global population [23]. Therefore, Internet enterprises had to deal with more data. As a global social networking site with more than 90 million members in 2010 [24], LinkedIn needed to analyze the behaviors of Internet users through a large number of logs every day for product optimization and advertisement serving. The basic paradigm of big data analytics, Lamdba [25,26], collects data from many systems through data acquisition components and then gathers it to big data platforms such as Spark or Hadoop. User behavior log data is obtained through distributed acquisition program. How to transfer massive log data to Hadoop which can realize the batch analysis of a large amount of data became a key issue [27]. LinkedIn used to transfer logs via ActiveMQ in the data integration scenario, but the performance problems of ActiveMQ laid bare against the big data integration scenario. Despite its complete message mechanism, flexible configuration methods and secure message delivery assurance, it was incapable for LinkedIn’s massive data transfer [28]. The big data integration scenario requires rapid transfer of massive log data to the big data platforms, which does not require complex configuration and the support of AMQP protocol. High-throughput transmission products were the most needed, which was not achievable by AcitveMQ.
        </p>

		<h2 id="References">References</h2>
	    <p>
        	[1] Mark Richards, Richard Monson-Haefel, David A Chappell(2009)  Java Message Service, 2nd Edition. Available at: https://www.oreilly.com/library/view/java-message-service/9780596802264/ (Accessed: 28 November 2023).
			[2] BYTEBYTEGO(2023)  How to choose a Message Queue? Kafka vs. RabbitMQ. Available at: https://blog.bytebytego.com/p/how-to-choose-a-message-queue-kafka#:~:text=When%20the%20cashier%20takes%20an,their%20coffee%20at%20the%20counter. (Accessed: 29 November 2023).
			[3] ByteByteGo(2023)  IBM MQ -> RabbitMQ -> Kafka ->Pulsar, How do message queue architectures evolve? Available at: https://www.linkedin.com/posts/bytebytego_systemdesign-coding-interviewtips-activity-7132625474358272000-rf9I?trk=public_profile_like_view (Accessed: 29 November 2023).
			[4] Jay Livens(2022)  What is a message queue? How an observability platform eases message queue monitoring. Available at: https://www.dynatrace.com/news/blog/what-is-a-message-queue/ (Accessed: 30 November 2023).
			[5] Thành Trần (2020)  Point-to-Point and Publish/Subscribe Messaging model. Available at: https://programmingsharing.com/point-to-point-and-publish-subscribe-messaging-model-2efc4d2b6726#:~:text=The%20difference%20between%20the%20point,the%20message%20will%20be%20consumed. (Accessed: 29 November 2023).

        </p>
	</article>
</div>

<! For intro
	Generative AI gained popularity with the developement of generative 
	adversarial networks (GANs), a deep learning architecture with the ability to create 
	photorealistic images of objects, scenes, and people.
>

</body>
	
<br><br><br><br><br><br><br><br>
<h2 style="color: white; margin: 0 22%;"> Conference Presentation: The Evolution of Message Queues: Architecture of distributed messaaging </h2>	
<div id="slide-container">
	<img id="slide" src"=slide1.jpg" alt="Slide 1" style="width:100%; max-width:800px;">

<div class="button-container">
	<button class="button" onclick="prevSlide()">Previous</button>
	<button class="button" onclick="nextSlide()">Next</button>
</div>

<div class="slide-number-container">
	<button class="button" onclick="showSlideNumber(1)">1</button>
	<button class="button" onclick="showSlideNumber(2)">2</button>
	<button class="button" onclick="showSlideNumber(3)">3</button>
	<button class="button" onclick="showSlideNumber(4)">4</button>
	<button class="button" onclick="showSlideNumber(5)">5</button>
</div>
</html>

<script>
	var slideImages = ["slide1.jpg", "slide2.jpg", "slide3.jpg", "slide4.jpg", "slide5.jpg"];
	var currentSlide = 0;

	function showSlide() {
		document.getElementById('slide').src = slideImages[currentSlide];
	}

	function nextSlide(){
		currentSlide = (currentSlide + 1) % slideImages.length;
		showSlide();
	}
	
	function prevSlide(){
		currentSlide = (currentSlide - 1 + slideImages.length) % slideImages.length;
		showSlide();
	}

	function showSlideNumber(slideNumber) {
		currentSlide = slideNumber - 1;
		showSlide();
	}
	showSlide();
</script>

<style>
	#slide-container {
		text-align: center;
		position: relative;
	}
	.button-container {
		position: absolute;
		bottom: 0;
		left: 50%;
		transform: translateX(-50%);
		margiin-bottom: -100px;
	}
	.button {
		padding: 10px 20px;
		background-color: #4CAF50;
		color: white;
		border: none;
		border-radius: 5px;
		font-size: 16px;
		cursor: pointer;
		margin: 0 5px;
	}
	.slide-number-container {
		position: absolute;
		bottom: 0;
		left: 50%;
		transform: translateX(-50%);
		margin-bottom: -50px;
	}
	
</style>
<br><br><br><br><br><br><br><br><br><br><br><br>
