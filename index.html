<link rel="stylesheet" type="text/css" href="css/styles.css">
<!DOCTYPE html>
<html>
    
<head>
	<h1 style="margin:0 9%; font-size:200%; padding:30px 6%; background-color: white; border: 0.8px solid #D3D3D3"><b>Quantum Minds</b></h1>
</head>

	<div style="margin: 0 9%; font-size:13px; padding: 0.1px 6%; background-color: #F5F5F5">
    	<p> 6653057 - Published: October 12, 2023 - Last Updated: December 5, 2023</p>
    </div>
    
<body background="image/TechBackground.jpg">
    <div class="NavBar">
		<a style="background-color: #21213E;" href="index.html">Article</a>
	    <a style="background-color: #28294D;" href="html/Technology">Technology</a>
	    <a style="background-color: #36376E;" href="html/Health.html">Health</a>
	    <a style="background-color: #414286;" href="html/Environment.html">Environment</a>
	    <a style="background-color: #4D4E9F;" href="html/Space.html">Space</a>
	    <a style="background-color: #5C5DBB;" href="html/Mathematics.html">Mathematics</a>
		<a style="background-color: #6769D5;" href="html/Physics.html">Physics</a>
    </div>

<div style="margin-top: 20px;">

	<div class="nav">
    	<ul style="list-style-type: none; padding-left: 0; margin: 0%;">
          <li><a href="#Abstract">Abstract</a></li>
          <li><a href="#Introduction">Introduction</a></li>
          <li><a href="#Analysis/Discussion">Analysis and Discussion</a></li>
          <li><a href="#Conclusion">Conclusion</a></li>
		  <li><a href="#References">References</a></li>
       	</ul>
    </div>

	<article>
		<h2 style="font-size: 30px;">Evolution of Message Queues: The architecture of Distributed Messaging</h2>
		<br>
	    <h2 id="Abstract">Abstract</h2>
	    <p>
        	Message queue is a form communication between the consumer and receiver that is used in our everyday lives. It is an asynchronous process that queue messages until it is viewed and discarded. The evolution of distributed messaging and its architecture of protocols have come very far in the short span of years. From Point-to-Point to Publish-and-Subscribe models, as well as from IMBMQ’s ability to produce high volumes of data to RabbitMQ’s flexibility in message sorting. But how does it exactly work and what can we expect from it?
        </p>
		
		<h2 id="Introduction">Introduction</h2>
	    <p>
        	What are message queues? It’s as simple as it sounds, queues in which messages are stored. If you look at your phones you will see emails all piled up for you to look at your leisure. That’s what message queue is. Another example and a good way to look at it is when you go to a café. Let’s say a customer wants some coffee, He goes up to the cashier and orders. For this to work effectively, The cashier cannot go to the back and start making coffee and wait for coffee to be made. especially when there are queues behind the customer. Who will take the orders? It’s not efficient at all. For a message queue to work, we need asynchronous processing, allowing the cashier to take the next order without delay. Persistence to ensure the customer’s orders are not missed if a problem occurs.
			
			<img src="image/MessageQueueDiagram.jpg" alt="Message Queue Diagram" width="750" height="500" style="margin: 50 0;">
			<a style="margin:50 0;"> https://blog.bytebytego.com/p/how-to-choose-a-message-queue-kafka#:~:text=When%20the%20cashier%20takes%20an,their%20coffee%20at%20the%20counter</a>
			
			Here's a simple diagram of message queue architecture. The cashier registers orders into a queue. The cashier is then free to take as many orders as he wants without any delays, while the coffee maker picks up new orders in batches. Once an order is complete, the coffee maker marks the order as done in the database. After, the customer can come collect the coffee at the counter at their leisure. There is no wasted time between the actions of workers whom we can refer to as ‘broker’.
			For large companies that need messaging systems, few key factors are considered: Scalability, Flexibility, Reliability, and efficiency.
		</p>
		<h2 id="Analysis/Discussion">Analysis & Discussion</h2>
	    <p>
			<h3>Point-to-Point and Publish-and-Subscribe Messaging Model</h3>
        	There are two styles in which a message can be queued. Point-to-point messaging and Publish-and-subscribe messaging. In a point-to-point model, messages are exchanged through queues, where messages are all individually unique to one consumer. After the consumer has received the message, it will then be discarded from the queue.<a href="#[5]">[5]</a>
			In a publish-and-subscribe messaging, the sender doesn’t need to know the receiver while in point-to-point they do. This is because the message model sends to multiple consumers through a certain topic, which links the sender and consumer. It is the choice of the consumers to subscribe to the topic or not.<a href="#[5]">[5]</a>
			“One important difference between point-to-point and publish/subscribe messaging is that p2p messages are always delivered, regardless of the current connection status of the receiver. Once a message is delivered to a queue, it stays there even if no consumer is currently connected.”<a href="#[1]">[1]</a>
		</p>
			<h3>The Evolution of Message Queuing Systems</h3>
        <p>
			One of the first few systems made was the IBMMQ. It was built for high scalability and reliability, able process high volumes of applications for commercial use. <a href="#[3]">[3]</a>
			Then came the RabbitMQ, an open-sourced system. Unlike the IBMMQ, it supports a variety of protocols such as sorting messages by topic and priority. It is lightweight and simple to use. RabbitMQ works like a messaging middleware. It pushes messages to consumers and deletes them upon acknowledgement, avoiding message pileups. It is able to handle tens of thousands of messages per second.<a href="#[2]">[2]</a><a href="#[3]">[3]</a>

			<img src="image/EvolutionDiagram.gif" alt="Evolution Diagram" width="300" height="500" style="margin: 50 20%;">
			
			<br>Unlike RabbitMQ, Kafka doesn’t support priority queues. It partitions topics into multiple brokers, allowing it to massively scale. Kafka was originally built for massive log processing. It retains messages until expiration and lets consumers pull messages at their own pace. This allows Kafka to  handle millions of data processing every second. Many modern applications integrate Kafka by default, making it a natural fit for most cases. <a href="#[2]">[2]</a>
			Lastly Pulsar, one of the latest message queuing systems, Uses alternative storage methods like bookkeeper and bookies to achieve high scalability and performance.

        </p>
		
		<h2 id="Conclusion">Conclusion</h2>
	    <p>
        	"Enterprises have produced more and more data ever since the birth of the Internet. In 2010, the arrival of the mobile Internet made the Internet, a super entrance, fully accessible and popular. The need to analyze the behaviors of Internet users through a large number of logs every day for product optimization and advertisement serving is increasing by the day."[6] Even though message queues continue to Evolve, with new, changing protocols, it is evident that each one has unique use that can't be replaced by others. One could say that distributed messaging made a huge improvement over these short span of years and given how there are still problems that are yet to be solved, such as message loss, message ordering, poison message, and high latency, it may be safe to assume that the evolution has just started and is yet to be over.<a href="#[8]">[8]</a>
        </p>

		<h2 id="References">References</h2>
	    <p>
        	<a id="[1]">[1] Mark Richards, Richard Monson-Haefel, David A Chappell(2009)  Java Message Service, 2nd Edition. Available at: https://www.oreilly.com/library/view/java-message-service/9780596802264/ (Accessed: 28 November 2023).</a>
		    <br><a id="[2]">[2] BYTEBYTEGO(2023)  How to choose a Message Queue? Kafka vs. RabbitMQ. Available at: https://blog.bytebytego.com/p/how-to-choose-a-message-queue-kafka#:~:text=When%20the%20cashier%20takes%20an,their%20coffee%20at%20the%20counter. (Accessed: 29 November 2023).</a>
			<br><a id="[3]">[3] ByteByteGo(2023)  IBM MQ -> RabbitMQ -> Kafka ->Pulsar, How do message queue architectures evolve? Available at: https://www.linkedin.com/posts/bytebytego_systemdesign-coding-interviewtips-activity-7132625474358272000-rf9I?trk=public_profile_like_view (Accessed: 29 November 2023).</a>
			<br><a id="[4]">[4] Jay Livens(2022)  What is a message queue? How an observability platform eases message queue monitoring. Available at: https://www.dynatrace.com/news/blog/what-is-a-message-queue/ (Accessed: 30 November 2023).</a>
			<br><a id="[5]">[5] Thành Trần (2020)  Point-to-Point and Publish/Subscribe Messaging model. Available at: https://programmingsharing.com/point-to-point-and-publish-subscribe-messaging-model-2efc4d2b6726#:~:text=The%20difference%20between%20the%20point,the%20message%20will%20be%20consumed. (Accessed: 29 November 2023).</a>
		    <br><a id="[6]">[6] Lucas Lee (2022)  The Past, Present and Future of Message Queue 1. Available at:https://www.vanus.ai/blog/the-past-present-and-future-of-message-queue-1/ (Accessed: 01 December 2023).</a>
		    <br><a id="[7]">[7] Nikolaos S. Loumis (2020)  The impact of iot communication protocols on efficient mobile crowdsensing. Available at: https://openresearch.surrey.ac.uk/esploro/outputs/doctoral/The-impact-of-iot-communication-protocols/99513693902346?institution=44SUR_INST (Accessed: 02 December 2023).</a>
        	<br><a id="[8]">[8] Pandio (2023)  The Evolution of Distributed Messaging: From Point-to-Point to ML and AI Integration. Available at:https://pandio.com/evolution-of-distributed-messaging/ (Accessed: 03 December 2023).</a>
	    </p>
	</article>
</div>

<! For intro
	Generative AI gained popularity with the developement of generative 
	adversarial networks (GANs), a deep learning architecture with the ability to create 
	photorealistic images of objects, scenes, and people.
>

</body>
	
<br><br><br><br><br><br><br><br>
<h2 style="color: white; margin: 0 22%;"> Conference Presentation: The Evolution of Message Queues: Architecture of distributed messaaging </h2>	
<div id="slide-container">
	<img id="slide" src"=slide1.jpg" alt="Slide 1" style="width:100%; max-width:800px;">

<div class="button-container">
	<button class="button" onclick="prevSlide()">Previous</button>
	<button class="button" onclick="nextSlide()">Next</button>
</div>

<div class="slide-number-container">
	<button class="button" onclick="showSlideNumber(1)">1</button>
	<button class="button" onclick="showSlideNumber(2)">2</button>
	<button class="button" onclick="showSlideNumber(3)">3</button>
	<button class="button" onclick="showSlideNumber(4)">4</button>
	<button class="button" onclick="showSlideNumber(5)">5</button>
</div>
</html>

<script>
	var slideImages = ["slide1.jpg", "slide2.jpg", "slide3.jpg", "slide4.jpg", "slide5.jpg"];
	var currentSlide = 0;

	function showSlide() {
		document.getElementById('slide').src = slideImages[currentSlide];
	}

	function nextSlide(){
		currentSlide = (currentSlide + 1) % slideImages.length;
		showSlide();
	}
	
	function prevSlide(){
		currentSlide = (currentSlide - 1 + slideImages.length) % slideImages.length;
		showSlide();
	}

	function showSlideNumber(slideNumber) {
		currentSlide = slideNumber - 1;
		showSlide();
	}
	showSlide();
</script>

<style>
	#slide-container {
		text-align: center;
		position: relative;
	}
	.button-container {
		position: absolute;
		bottom: 0;
		left: 50%;
		transform: translateX(-50%);
		margiin-bottom: -100px;
	}
	.button {
		padding: 10px 20px;
		background-color: #4CAF50;
		color: white;
		border: none;
		border-radius: 5px;
		font-size: 16px;
		cursor: pointer;
		margin: 0 5px;
	}
	.slide-number-container {
		position: absolute;
		bottom: 0;
		left: 50%;
		transform: translateX(-50%);
		margin-bottom: -50px;
	}
	
</style>
<br><br><br><br><br><br><br><br><br>
